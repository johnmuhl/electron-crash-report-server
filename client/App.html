<:Window on:scroll='scroll()' />
<AppBar />
<ReportFilters />
<ReportList />
{{#if $report}}
<ReportDetails />
{{/if}}

<script>
/* global devicePixelRatio document fetch Headers Image localStorage window */
import AppBar from "./AppBar.html";
import ReportDetails from "./ReportDetails.html";
import ReportFilters from "./ReportFilters.html";
import ReportList from "./ReportList.html";

export default {
  components: {
    AppBar,
    ReportDetails,
    ReportFilters,
    ReportList,
  },
  methods: {
    async scroll() {
      const authorization = this.store.get("authorization");
      const endOfList = this.store.get("endOfList");
      const fetchPending = this.store.get("fetchPending");
      const limit = this.store.get("limit");
      const offset = this.store.get("offset");
      const scrollPosition = window.pageYOffset;
      const { clientHeight, scrollHeight } = document.documentElement;

      if (
        endOfList ||
        (fetchPending && scrollHeight - (scrollPosition + clientHeight) < 120)
      ) {
        return null;
      }

      const headers = new Headers({ authorization, limit, offset });

      try {
        this.store.set({ fetchPending: true });

        const response = await fetch("/reports", { headers });

        if (response.status !== 200) return console.error(response);

        const next = await response.json();
        const prev = this.store.get("reports");
        const reports = prev.concat(next);
        const prevApps = this.store.get("applications");

        if (prev.length === reports.length) {
          return this.store.set({
            endOfList: true,
            fetchPending: false,
          });
        }

        reports
          // eslint-disable-next-line no-underscore-dangle
          .map(report => report.body._productName)
          .filter(item => item != null)
          .filter(item => item.toString().trim().length)
          .filter(item => !!item)
          .filter((item, index, array) => array.indexOf(item) === index)
          .forEach(item => {
            if (prevApps.indexOf(item) === -1) {
              prevApps.push(item);
            }
          });

        return this.store.set({
          applications: prevApps.sort(),
          fetchPending: false,
          offset: offset + limit,
          reports: prev.concat(next),
        });
      } catch (error) {
        throw new Error(error);
      }
    },
  },
  async oncreate() {
    // Restore filters from localStorage
    if (localStorage.application || localStorage.closed) {
      const { application } = localStorage || "";
      let { closed } = localStorage;

      if (closed == null) closed = false;
      closed = closed === "true";

      this.store.set({ application, closed });
    }

    try {
      const headers = new Headers({
        authorization: this.store.get("authorization"),
      });
      const response = await fetch("/reports", { headers });

      if (response.status !== 200) return console.error(response);

      const img = new Image();
      const reports = await response.json();
      const applications = reports
        // eslint-disable-next-line no-underscore-dangle
        .map(report => report.body._productName)
        .filter(item => item != null)
        .filter(item => item.toString().trim().length)
        .filter(item => !!item)
        .filter((item, index, array) => array.indexOf(item) === index)
        .sort();

      this.store.set({ applications, reports });
      img.src = devicePixelRatio > 1 ? "/icons-2x.png" : "/icons-1x.png";

      return this;
    } catch (error) {
      throw new Error(error);
    }
  },
};
</script>
